## MVC
"模型-视图-控制器"（MVC）是一种软件架构模式，用于设计和组织应用程序的不同组成部分。它的主要目的是将应用程序的核心逻辑、用户界面和用户输入分离开来，从而提高代码的可维护性、可扩展性和可重用性。在MVC架构中，模型、视图和控制器三者之间存在特定的引用关系，其设计有助于分离关注点，使得应用程序更易于开发和维护。

1. **模型（Model）**：

模型表示应用程序的核心数据和业务逻辑。它负责处理数据的存储、检索、更新和计算等任务。模型与数据相关，但并不直接处理用户界面或用户输入。
 
模型通常包含应用程序的状态和数据结构，并提供操作数据的方法。在MVC中，模型是独立于视图和控制器的。模型不应直接引用视图或控制器。它负责处理数据和业务逻辑，但不应与用户界面相关。

2. **视图（View）**：

视图负责显示模型中的数据以及向用户展示用户界面。它将数据呈现为用户可以理解的形式，如文本、图表、图像等。视图的任务是将数据可视化并呈现给用户，但它不会包含业务逻辑。在MVC中，视图是 passively 更新的，即它只是根据模型的状态来更新自己的显示，不直接处理用户输入。

视图可以引用模型，以便获取要显示的数据。这有助于视图从模型中获取数据以显示给用户。但是，在典型的MVC实现中，视图不应直接引用模型，而是通过控制器来获取所需的数据。这有助于分离关注点并降低耦合。


3. **控制器（Controller）**：

控制器是用户输入和模型之间的桥梁。它接收来自用户界面的输入（如点击、键盘输入等），然后根据这些输入调用模型的方法来更新数据。控制器还可以根据需要更新视图，以反映模型的变化。控制器负责协调视图和模型之间的通信，但它本身不处理业务逻辑。

控制器可以引用模型，以便处理用户输入并相应地更新模型。它负责从视图接收用户输入，然后根据输入更新模型的状态。控制器也可以更新视图以反映模型的变化。控制器还可以调整视图的外观和行为。


在MVC中，三者之间的引用关系如下：

- 视图可以引用模型，以便获取要显示的数据。
- 控制器可以引用视图和模型，以便处理用户输入并相应地更新模型和视图。

这样的设计有几个优点：

1. **分离关注点**：MVC将应用程序分成不同的部分，使开发人员可以集中精力处理特定的任务，从而提高代码的可读性和可维护性。

2. **可维护性和可扩展性**：由于各组件之间相互分离，所以对模型、视图或控制器的更改不太可能影响其他部分，从而使得应用程序更易于维护和扩展。

3. **可重用性**：通过将核心逻辑与用户界面分开，可以更容易地重用模型和控制器部分，例如在不同的应用程序中使用相同的模型。

4. **并行开发**：不同开发人员可以同时开发不同的组件，因为它们之间的接口是明确定义的。

总之，MVC是一种常用的软件架构模式，有助于组织代码并提高应用程序的质量和可维护性。然而，随着时间的推移，也出现了其他变体和衍生模式，如MVP（Model-View-Presenter）和MVVM（Model-View-ViewModel），以更好地满足不同应用程序的需求。

## MVP
当谈到软件架构模式时，除了MVC，还有一种常见的模式是MVP（Model-View-Presenter）。MVP也旨在将应用程序分成不同的组件，以提高可维护性、可测试性和可重用性，同时分离关注点。MVP适用于需要更强调用户界面和用户交互的应用程序，如图形界面应用程序。

下面是MVP模式中三个主要组件的解释和它们之间的引用关系：

1. **模型（Model）**：

模型在MVP中的角色与MVC中类似，它包含应用程序的数据和业务逻辑。模型负责处理数据的操作，例如存储、检索和计算，同时不涉及用户界面或用户交互。

主持人可以引用模型。模型负责数据的操作和管理，包括存储、检索和计算等。主持人可能会使用模型来获取所需的数据，但主持人通常不直接操作模型。

2. **视图（View）**：

视图负责呈现模型中的数据给用户，并负责接收用户的输入。与MVC中的视图类似，视图在MVP中也被设计为尽可能被动。它只负责将数据呈现给用户，然后将用户的输入传递给主持人（Presenter）进行处理。

视图引用主持人。视图负责将用户的输入传递给主持人，然后由主持人来处理用户输入并相应地更新模型和视图。视图通常会实现一个接口，主持人可以使用这个接口来与视图进行通信。

3. **主持人（Presenter）**：

主持人是MVP模式中的核心组件，类似于MVC中的控制器。主持人负责协调视图和模型之间的交互。它接收来自视图的用户输入，然后根据输入更新模型并更新视图的显示。主持人还可以包含一些业务逻辑，以确保应用程序的行为。

主持人引用视图。主持人充当视图和模型之间的中介，负责处理用户界面逻辑和用户输入。它从视图中接收用户输入，并根据输入更新模型的状态，然后要求视图刷新以反映模型的变化。主持人可能会包含一些业务逻辑，但通常不直接操作模型的数据。

引用关系如下：

- 视图引用主持人：视图将用户的输入传递给主持人，然后由主持人来处理用户输入并相应地更新模型和视图。
- 主持人引用视图和模型：主持人通过视图来显示数据，并通过模型来操作和管理数据。

MVP的设计优点包括：

1. **分离关注点**：MVP将用户界面、数据和业务逻辑分开，使代码更易于管理和理解。
2. **可测试性**：由于业务逻辑位于主持人中，可以更轻松地对其进行单元测试，而视图可以模拟用户界面交互。
3. **可重用性**：模型和主持人可以在不同的应用程序中进行重用，从而提高开发效率。
4. **适应复杂界面**：MVP适用于具有复杂用户界面和用户交互的应用程序，可以更清晰地组织界面逻辑。

需要注意的是，MVC和MVP之间有些相似之处，但也存在一些差异。MVP更加关注将视图和主持人分开，使视图更被动，主持人负责处理用户输入和业务逻辑。而MVC中的控制器更加平衡视图和模型之间的关系。选择使用哪种模式取决于应用程序的特定需求和团队的偏好。
## MVVM
当谈到软件架构模式时，另一个常见的模式是MVVM（Model-View-ViewModel）。MVVM旨在进一步提高应用程序的可维护性、可测试性和可扩展性，同时将用户界面与数据逻辑解耦。MVVM适用于需要强调数据绑定和响应式编程的应用程序，特别是适用于现代前端开发。

下面是MVVM模式中三个主要组件的解释以及它们之间的引用关系：

1. **模型（Model）**：

模型在MVVM中的角色与MVC和MVP中类似，它包含应用程序的数据和业务逻辑。模型负责处理数据操作，但不涉及用户界面。

模型不直接引用其他组件。模型负责数据的操作和管理，不涉及用户界面或数据绑定。

2. **视图（View）**：

视图在MVVM中与MVC和MVP中的视图类似，负责呈现模型中的数据给用户。MVVM中的一个关键概念是数据绑定，它允许视图自动地反映模型的状态变化。

视图引用视图模型。通过数据绑定，视图将视图模型中的数据绑定到界面元素，从而实现数据的自动更新。视图不直接操作数据，而是通过视图模型来呈现数据。

3. **视图模型（ViewModel）**：

视图模型是MVVM模式中的新组件，它充当视图和模型之间的中介。视图模型包含用于呈现视图所需的数据和逻辑，以及处理用户交互的命令。它的任务是将模型中的数据转换为视图可用的形式，并处理用户输入，并通知模型进行数据操作。视图模型引用模型。

视图模型负责管理模型数据，并将其转化为视图可以使用的形式。视图模型充当了视图和模型之间的中介，处理数据转换和逻辑，以及响应用户输入。视图模型可以包含数据绑定的命令，以响应用户的操作。

引用关系如下：

- 视图引用视图模型：视图通过数据绑定将视图模型中的数据绑定到界面元素，从而实现数据的自动更新。
- 视图模型引用模型：视图模型负责管理模型数据，并将其转化为视图可以使用的形式。
- 视图模型可以引用其他组件，如服务或数据提供程序，以获取或操作数据。

MVVM的设计优点包括：

1. **分离关注点**：MVVM将用户界面逻辑与数据逻辑分开，使得代码更易于维护和理解。
2. **数据绑定**：MVVM中的数据绑定机制使得视图可以自动地反映模型的变化，减少了手动更新界面的需要。
3. **可测试性**：由于视图模型是纯粹的逻辑单元，可以更轻松地对其进行单元测试，而无需关心界面细节。
4. **适应现代前端开发**：MVVM特别适用于现代前端开发，如Web应用程序和移动应用程序，可以更好地利用响应式编程和数据绑定的优势。

需要注意的是，MVVM与MVC和MVP之间的主要区别在于视图模型的引入，它充当视图和模型之间的中介。MVVM的灵活性和响应式特性使其成为处理复杂的用户界面和交互的强大工具。选择使用哪种模式应该根据应用程序的特定需求和技术栈来决定。


## 主要是分离模型和视图。MVVM双向绑定非常优秀，View的变动，会自动反应到ViewModel上,反之亦然。
在 UML 类图中，箭头的方向通常表示类之间的调用关系。箭头指向被调用的一方，也就是调用的目标。这意味着箭头的尾部表示调用者，箭头的头部表示被调用者。

例如，如果在类图中有一个箭头从类 A 指向类 B，那么这意味着类 A 调用了类 B。箭头的方向从调用者（A）指向被调用者（B）。

在 MVVM 架构中，箭头的方向同样可以表示调用关系。例如，如果在类图中有一个箭头从 View 指向 ViewModel，那么这表示 View 调用了 ViewModel。同样，如果箭头从 ViewModel 指向 Model，那么表示 ViewModel 调用了 Model。箭头的方向始终从调用者指向被调用者。

单向箭头：在单向箭头表示的引用关系中，通常箭头的起始点表示调用者，而箭头的终点表示被调用者。

![起始于用户界面和业务逻辑分离](https://github.com/TheWorld-SQX/BestPractices_CSharpCode/blob/master/Image/640.jpg)

ps:"passes calls to" 描述了对象之间的协作方式，其中一个对象将某个方法的调用传递给另一个对象来处理特定的操作。具体的含义可能会根据上下文和使用的设计模式而有所不同。

## 架构发展演变
Backend side architecture evolution (N-layered, DDD, Hexagon, Onion, Clean Architecture) 链接：
[medium推文](https://medium.com/@iamprovidence/backend-side-architecture-evolution-n-layered-ddd-hexagon-onion-clean-architecture-643d72444ce4)
[中译](https://mp.weixin.qq.com/s/R0atDk4oZ57Lt36ut-BTcw)

## 高层模块和低层模块

所谓依赖是指如果一个模块A使用另一个模块B，我们称模块A依赖模块B。在应用程序中，有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外，有一些高层次的类，这些类封装了某些复杂的逻辑，这些类我们称之为高层模块。高层次模块要完成自己封装的功能，就必须要使用低层模块，于是高层模块就依赖于低层模块。

高层模块依赖于低层模块的现象，在传统的结构化程序设计中，是非常常见的。因为结构化程序设计就是采用由上到下、逐层分解的策略，把大型和复杂的软件系统分解成若干个人们易于理解和易于分析的子系统。这里的分解是根据软件系统的逻辑特性和系统内部各成分之间的逻辑关系进行的。

高层模块通常是应用程序的核心业务逻辑，低层模块则是底层的实现细节。依赖倒置原则的目标是通过将高层模块与低层模块的依赖关系反转，来实现系统的解耦和灵活性。

## 为什么说是依赖反转
在传统的软件设计中，通常是高层模块依赖于低层模块，也就是高层模块会直接使用低层模块的具体实现。这种依赖关系导致了高层模块与低层模块之间的紧耦合，当低层模块发生变化时，高层模块可能会受到影响，从而降低了系统的灵活性和可维护性。

这是因为在传统的软件开发中，通常是高层模块依赖于低层模块，因为高层模块需要底层模块的具体实现来完成其功能。这种依赖关系是自上而下的，高层模块控制和使用底层模块。这种依赖关系会导致高层模块与低层模块之间紧密耦合，使得修改低层模块的实现时可能会影响到高层模块，从而降低了系统的灵活性和可维护性。

而在依赖反转原则中，依赖关系被反转了。高层模块不再直接依赖于底层模块的具体实现，而是依赖于底层模块所定义的抽象接口。这使得高层模块控制了抽象接口，而底层模块则需要遵循这个接口来提供具体的实现。

它改变了传统的依赖关系方向，将控制权从底层模块转移到了高层模块，并通过抽象接口实现了高层模块对底层模块的控制。


依赖倒置原则的目标是将这种传统的依赖关系反转过来，即高层模块不再直接依赖于低层模块的具体实现，而是依赖于低层模块定义的抽象接口或协议。这种反转的依赖关系意味着高层模块控制了与低层模块的交互方式和接口，低层模块则通过实现这些接口来适应高层模块的需求。这种设计方式将实际的控制权从低层模块转移到了高层模块，从而实现了系统架构的灵活性和可维护性。

总的来说，"依赖关系的反转" 表示的是传统的依赖方向被颠倒，高层模块不再紧密依赖于低层模块的实现细节，而是通过抽象接口来定义交互方式。这种反转的设计思想有助于实现解耦、灵活性和可测试性，从而提高软件系统的质量和可维护性。

## 依赖注入，依赖反转，依赖倒置

这段描述强调了在软件开发中引入依赖反转原则和六边形架构的重要性，以及这些变化如何影响了开发者对依赖关系的控制和管理。让我为你解释一下：

1. **依赖反转原则的发现：** 在过去，模块通常会直接引用其下一个模块，这可能导致紧耦合和依赖关系的混乱。然而，随着时间的推移，依赖反转原则逐渐被提出和发展。依赖反转原则强调高层模块不应该直接依赖于低层模块，而应该通过接口或抽象来定义依赖关系，从而实现了控制依赖关系的方向。

2. **学会控制依赖关系：** 这里强调这一变化对软件开发人员来说是一个难得的机会，因为他们终于学会了如何控制依赖关系的方向。通过依赖反转原则，开发者可以将依赖关系指向他们希望的方式，从而降低模块之间的紧耦合性，提高了代码的灵活性和可维护性。

3. **业务逻辑不再引用数据访问层：** 在传统的架构中，业务逻辑常常会直接引用数据访问层，导致了业务逻辑与数据存储的强耦合。而引入依赖反转原则后，业务逻辑不再直接引用数据访问层，而是通过抽象接口来定义依赖关系，实现了业务逻辑与数据访问的解耦。

4. **链接提供详细解释：** 提供的链接可能包含详细的解释，涵盖了为什么业务逻辑不再引用数据访问层以及接口与此相关的内容。该链接可能会详细介绍接口的作用，以及如何通过接口来定义和管理模块之间的依赖关系。

综上所述，这段描述强调了依赖反转原则和六边形架构对于改善软件架构的重要性，以及如何通过控制依赖关系的方向来提高代码质量和可维护性。链接提供了更深入的信息，可以进一步了解相关概念和实践。

当我们论证之前提到的关于依赖反转原则和六边形架构的话题时，我们可以通过一个具体的C#示例来说明这些概念是如何在实际开发中应用的。让我们考虑一个简单的订单处理系统作为示例。

**业务需求：** 假设我们正在开发一个订单处理系统，其中包括以下几个关键组件：订单创建、库存管理和邮件通知。

**传统架构：** 在传统的架构中，这些组件可能会直接相互引用，导致高耦合和难以维护的问题。

```csharp
// 传统的紧耦合代码示例
class OrderService
{
    private InventoryService _inventoryService = new InventoryService();
    private EmailService _emailService = new EmailService();

    public void ProcessOrder(Order order)
    {
        _inventoryService.UpdateInventory(order);
        _emailService.SendOrderConfirmation(order);
    }
}
```

在这个示例中，`OrderService` 直接创建了 `InventoryService` 和 `EmailService` 的实例，导致了紧耦合的问题。

**引入依赖反转原则和六边形架构：** 现在，让我们通过引入依赖反转原则和六边形架构来重构这个示例。

首先，我们定义接口来表示库存管理和邮件通知功能：

```csharp
interface IInventoryService
{
    void UpdateInventory(Order order);
}

interface IEmailService
{
    void SendOrderConfirmation(Order order);
}
```

然后，我们实现具体的库存管理和邮件通知服务：

```csharp
class InventoryService : IInventoryService
{
    public void UpdateInventory(Order order)
    {
        // 实现库存更新逻辑
    }
}

class EmailService : IEmailService
{
    public void SendOrderConfirmation(Order order)
    {
        // 实现邮件发送逻辑
    }
}
```

接下来，我们将依赖注入到 `OrderService` 中，以遵循依赖反转原则：

```csharp
class OrderService
{
    private readonly IInventoryService _inventoryService;
    private readonly IEmailService _emailService;

    public OrderService(IInventoryService inventoryService, IEmailService emailService)
    {
        _inventoryService = inventoryService;
        _emailService = emailService;
    }

    public void ProcessOrder(Order order)
    {
        _inventoryService.UpdateInventory(order);
        _emailService.SendOrderConfirmation(order);
    }
}
```

在这个重构后的示例中，`OrderService` 通过构造函数接收 `IInventoryService` 和 `IEmailService` 的实例，实现了依赖反转。这样，各个组件之间的依赖关系变得清晰，且可以灵活替换具体的实现，而不会影响到其他部分的代码。

这个具体示例演示了如何在C#中应用依赖反转原则和六边形架构，通过解耦和管理依赖关系，提高了代码的可维护性和灵活性。在这种架构下，业务逻辑（`OrderService`）不再直接引用底层模块（`InventoryService` 和 `EmailService`），而是通过接口进行交互，实现了依赖关系的反转。

## wpf项目里的IoC 

在 WPF (Windows Presentation Foundation) 应用程序中，MVVM（Model-View-ViewModel）是一种架构模式，而 IoC（Inversion of Control）是一种设计原则，通常与依赖注入（Dependency Injection，DI）结合使用，用于实现松耦合和可测试性。

**MVVM（Model-View-ViewModel）**：
MVVM 是一种用于分离界面表示、业务逻辑和数据的设计模式。它将应用程序分为三个主要部分：

1. **Model（模型）**：表示应用程序的业务逻辑和数据。它包含了数据存储、处理和操作的逻辑。

2. **View（视图）**：表示用户界面。在 WPF 中，View 是 XAML 文件，它负责展示数据和与用户进行交互。

3. **ViewModel（视图模型）**：是 View 和 Model 之间的桥梁。ViewModel 包含了与用户界面相关的逻辑，将 Model 中的数据适配成 View 所需的形式。它还提供了命令、属性绑定等机制，用于实现用户界面和业务逻辑之间的交互。

**IoC（Inversion of Control）**：
IoC 是一种设计原则，它是一种反转控制的概念，用于将对象的创建和管理责任从调用者转移到一个独立的容器中。IoC 容器负责创建对象、解决对象之间的依赖关系，并将对象提供给需要它们的部分。

**依赖注入（Dependency Injection，DI）**：
依赖注入是实现 IoC 的一种具体方式，它是指将一个对象所需的依赖通过构造函数、方法参数或属性注入到对象中，而不是在对象内部创建或获取这些依赖。这有助于解耦和灵活性，使得对象的依赖关系可以更容易地管理和替换。

在 MVVM 架构中，使用 IoC 和依赖注入可以帮助解决 ViewModel 的创建和管理问题，以及在 ViewModel 中需要访问服务或其他依赖的情况。通过 IoC 容器，可以自动解决 ViewModel 的依赖并提供相应的实例，使代码更具可维护性、可测试性和松耦合性。

在 WPF 中，你可以使用各种 IoC 容器库，如 Prism、Unity、Autofac 等，来帮助管理 MVVM 架构中的依赖注入和对象创建。这些库提供了一些机制来配置容器并在应用程序中使用依赖注入。

## 实现依赖注入的关键是将接口类型当作参数类型  在需要注入服务的对象的构造函数上吗  
是的，实现依赖注入的关键之一是通过构造函数将接口类型作为参数。这是因为 ASP.NET Core 使用构造函数注入的方式来完成依赖注入。当你在一个类的构造函数中声明一个接口类型的参数时，ASP.NET Core 的依赖注入容器会负责提供相应的实现。

例如，如果你有一个服务接口 `IFooService` 和其实现类 `FooService`，你可以将 `IFooService` 作为其他类的构造函数参数，并在 `Startup` 类的 `ConfigureServices` 方法中注册服务。

```csharp
// 服务接口
public interface IFooService
{
    void DoSomething();
}

// 服务实现类
public class FooService : IFooService
{
    public void DoSomething()
    {
        // 实现具体的逻辑
    }
}
```

在 `Startup` 类的 `ConfigureServices` 方法中注册服务：

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddTransient<IFooService, FooService>();
    // 其他服务的注册...
}
```

然后，在你的控制器或其他类中，通过构造函数注入 `IFooService`：

```csharp
public class MyController : Controller
{
    private readonly IFooService _fooService;

    public MyController(IFooService fooService)
    {
        _fooService = fooService;
    }

    // 在这里可以使用 _fooService
}
```

ASP.NET Core 的依赖注入容器会自动解析 `IFooService`，并在创建 `MyController` 实例时提供 `FooService` 的实例。这种方式使得你可以方便地将服务注入到需要的地方，实现代码的解耦、可测试性和可维护性。

## 除了构造函数注入外，ASP.NET Core 还支持以下几种依赖注入的方式：

1. **属性注入：** 通过在类的属性上标记 `[FromServices]` 特性，你可以将服务注入到属性中。这种方式在某些情况下可能更为方便，但要注意属性注入在某些场景下可能不如构造函数注入直观。

    ```csharp
    public class MyController : Controller
    {
        [FromServices]
        public IFooService FooService { get; set; }

        public IActionResult MyAction()
        {
            FooService.DoSomething();
            return View();
        }
    }
    ```

2. **方法注入：** 通过在方法的参数上标记 `FromServices` 特性，你可以将服务注入到方法中。这种方式适用于只在特定方法中需要使用某个服务的情况。

    ```csharp
    public class MyController : Controller
    {
        public IActionResult MyAction([FromServices] IFooService fooService)
        {
            fooService.DoSomething();
            return View();
        }
    }
    ```

3. **直接从容器获取服务：** 在某些场景下，你可以通过直接从容器获取服务。这种方式在控制器的构造函数中无法使用，因为容器在构造函数调用之前可能还未完全初始化。你可以通过 `HttpContext.RequestServices` 获取容器，然后获取服务。

    ```csharp
    public class MyController : Controller
    {
        public IActionResult MyAction()
        {
            var fooService = HttpContext.RequestServices.GetService<IFooService>();
            fooService.DoSomething();
            return View();
        }
    }
    ```

虽然这些方式在某些场景下是可行的，但构造函数注入通常是推荐的方式。它具有清晰的语法，使得依赖关系在类的构造函数中一目了然，便于维护和测试。其他方式在一些特定情况下可能更为方便，但也可能引入一些不太直观的依赖关系。选择合适的方式取决于你的具体需求和偏好。
