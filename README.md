# BestPractices_CSharpCode
关于面向对象编程（OOP）一些概念知识和.NET下开发程序需要的一些相关概念知识

- [面向对象编程思想](#面向对象编程思想)
  - [类和对象](#类和对象)
  - [封装](#封装)
  - [继承](#继承)
  - [多态](#多态)
  - [抽象和接口](#抽象和接口)
- [在VS上C#编写的程序是如何运行的](#在VS上C#编写的程序是如何运行的)
- [？进程和线程](#？进程和线程)
- [操作系统怎么知道要给每个进程分配多少计算机资源的](#操作系统怎么知道要给每个进程分配多少计算机资源的)
- [谁可以创建或者说划分出一个进程或线程](#谁可以创建或者说划分出一个进程或线程)
- [CLR为什么可以管理进程和线程](#CLR为什么可以管理进程和线程)
- [C#异步编程](#C#异步编程)
- [C#如何做到高效的异步编程，实际生产时，编码时需要哪些规范](#C#如何做到高效的异步编程，实际生产时，编码时需要哪些规范)
- [本来就有线程，为撒又要异步编程](#本来就有线程，为撒又要异步编程)
- [C#如何做到高效的多线程编程，实际生产时，编码时需要哪些规范](#C#如何做到高效的多线程编程，实际生产时，编码时需要哪些规范)

## 面向对象编程思想
<a name="面向对象编程思想"></a>
面向对象编程思想（Object-Oriented Programming, OOP）是一种软件开发方法，它将程序中的数据和操作数据的方法组织成对象，通过对象之间的交互来实现程序的功能。面向对象编程将现实世界中的实体抽象为程序中的对象，通过模拟对象之间的关系和行为（也就是 类型和行为），实现对问题域的建模和解决。

<a name="类和对象"></a>
1.类和对象：

- 类是对象的模板，描述了对象的属性和行为。它定义了对象的结构和行为的集合。   
- 对象（Object）是类的实例，表示具体的实体。
- 对象是现实世界中的实体，可以具有状态（属性）和行为（方法）。

<a name="封装"></a>
2.封装（Encapsulation）：

- 封装是将数据和操作数据的方法封装在一起，形成一个对象。  
- 对象对外隐藏了内部的实现细节，只提供了公共接口（公共接口：对象对外部提供的一组可访问和操作对象数据的方法。），其他对象只能通过这些接口访问和操作对象的数据。  

<a name="继承"></a>
3.继承（Inheritance）：

- 继承是一种机制，通过定义一个新的类来继承现有类的属性和方法。  
- 继承允许新的类拥有基类的特性，可以重用已有的代码，并且可以在基础上添加新的功能或修改行为。  

<a name="多态"></a>
4.多态（Polymorphism）：

- 多态是指同一个方法名可以在不同的对象上具有不同的行为。
- 多态使得可以用一个通用的方式来处理不同类型的对象，提高了代码的灵活性和可扩展性。
- 多态是指同一个方法名可以在不同的对象上具有不同的行为。
- 多态性允许通过父类引用指向子类对象，实现运行时多态性。
- 多态通过方法的重写（覆盖）和方法的重载来实现，提高了代码的灵活性和可扩展性。  

<a name="抽象和接口"></a>
5.抽象（Abstraction）和接口：

- 抽象是一种将类的共同特征提取出来形成抽象类或接口的过程。
- 抽象类是不能被实例化的类，用于定义具有共同特征的子类的基本行为和属性。
- 接口是一组方法、属性和事件的集合，用于定义对象之间的契约。类可以实现接口，满足接口定义的行为。  

<a name="在VS上C#编写的程序是如何运行的"></a>
## 在VS上C#编写的程序是如何运行的
- 源代码编写： 在VS中，程序员使用C#语言编写源代码，实现程序的逻辑和功能。

- 编译器处理： 一旦源代码编写完成，C#编译器将源代码转换为中间语言（Intermediate Language, IL），也称为托管代码。IL是一种与特定计算机体系结构无关的中间表示形式。

- 程序集生成： 编译器将生成的IL代码打包成程序集（Assembly），其中包含了程序的IL代码、元数据（描述程序的结构和特性）、资源文件等（JIT编译：CLR将IL转换为机器码）。程序集通常以DLL或EXE的形式存在。

- 加载程序集： 当运行C#程序时，操作系统将加载程序集到内存中。这个过程通常由CLR（Common Language Runtime）负责，CLR是.NET运行时的核心组件。

- 初始化： 一旦程序集被加载到内存中，CLR负责初始化运行环境，包括分配和管理内存、设置堆栈、创建主线程等。CLR还执行一些必要的初始化操作，例如加载系统程序集、安全检查等。

- 主线程执行： CLR创建一个主线程，并从程序集中找到入口点（Entry Point），通常是Main方法。主线程负责执行程序的初始化代码和入口方法，它是程序的起点。

- 用户交互和事件处理： 如果程序包含用户界面，主线程将监听用户的输入事件，如鼠标点击、键盘输入等。主线程通过消息循环机制响应用户操作，更新UI并触发相应的事件处理逻辑。

- 多线程并发： 在C#程序中，可以创建多个线程来同时执行不同的任务。例如，可以使用Task、Thread或async/await等机制创建额外的线程来处理耗时的操作，如网络请求、文件读写等。这些线程由CLR的线程调度器进行管理和调度。

- 线程调度和并发访问： 在多线程场景下，CLR的线程调度器负责决定哪个线程在某个时间片段内执行。调度器根据优先级、时间片轮转等策略来决定线程的执行顺序。多个线程可能同时访问共享的资源，为了保证数据的一致性和避免竞态条件，需要使用同步机制（如锁、互斥量、信号量等）来协调线程之间的访问。

- 指令执行： 当线程执行时，CPU将逐条执行线程的指令。指令包括算术运算、条件判断、函数调用等操作。CLR负责将C#代码转换为对应的机器码，CPU根据机器码执行相应的指令。

- 任务完成： 程序的执行会持续进行，直到达到退出条件或主动终止。在程序结束时，CLR会执行一些清理操作，如释放资源、关闭线程等。

以上是一个概括性的描述，实际上涉及的细节非常复杂。C#程序的运行涉及到编译、加载、初始化、线程调度、指令执行等多个阶段和环节，这些概念和流程的配合协作，使得程序能够顺利运行并完成相应的任务。

<a name="？进程和线程"></a>
## ？进程和线程（是计算机科学中的概念）

进程（Process）是指正在运行的一个程序的实例。它是操作系统中进行资源分配和调度的基本单位。一个进程包含了程序的代码、数据、堆栈和相关的系统资源（如打开的文件、网络连接等）。每个进程都有独立的地址空间，它们之间相互隔离，不会直接共享内存。

线程（Thread）是进程中的一个执行单元。一个进程可以包含多个线程，线程共享进程的地址空间和资源。线程之间可以并发执行，每个线程有自己的程序计数器、栈和局部变量，但共享进程的全局变量和堆内存。

因此，进程和线程都是抽象的概念，用于描述程序的执行和资源管理方式。它们在操作系统中起到不同的作用，进程是资源分配的基本单位，而线程是执行单位，多个线程可以在同一个进程中并发执行。

<a name="操作系统怎么知道要给每个进程分配多少计算机资源的"></a>
## 操作系统怎么知道要给每个进程分配多少计算机资源的（进程是资源分配的基本单位）

操作系统根据一些策略和算法来确定要给每个进程分配多少计算机资源。这个过程称为*进程调度和资源管理*。

以下是操作系统进行资源分配的一般原则和方法：

- 优先级和调度算法： 操作系统为每个进程分配一个优先级，表示进程相对于其他进程的重要程度。优先级通常根据进程的类型、紧急性、响应时间等因素确定。操作系统使用调度算法来决定哪些进程应该被优先调度执行。

- 时间片轮转： 操作系统采用时间片轮转算法来分配CPU时间。每个进程被分配一个时间片，在时间片用完后，操作系统将CPU切换到下一个进程。这样，每个进程都有公平的机会使用CPU资源。

- 内存管理： 操作系统负责将内存分配给进程。它维护一个内存管理表，记录每个进程的内存需求和已分配的内存块。根据进程的大小和内存的可用性，操作系统决定如何分配内存资源给每个进程。

- 文件和I/O资源管理： 操作系统管理文件和I/O设备资源的分配。它维护文件表和设备表，记录文件和设备的使用情况。当进程请求使用文件或进行I/O操作时，操作系统根据资源的可用性和访问权限来分配给进程相应的资源。

- 并发控制和同步： 多个进程可能同时访问共享资源，如共享内存、文件等。为了保证数据的一致性和避免竞态条件，操作系统提供了并发控制和同步机制，如锁、信号量、互斥量等。这些机制确保每个进程能够按照规定的顺序和方式访问共享资源，避免冲突和数据损坏。

通过以上的策略和算法，操作系统能够根据进程的优先级、时间片、内存需求、文件和I/O资源等因素来分配适当的计算机资源给每个进程，以满足各个进程的运行需求。这样可以实现资源的合理利用和进程的高效执行。

<a name="谁可以创建或者说划分出一个进程或线程"></a>
## 谁可以创建或者说划分一个进程或线程

在操作系统中，通常有以下实体可以创建或者划分出一个进程或线程：

- 操作系统自身： 操作系统内核是最高权限的程序，它负责管理计算机的硬件资源和执行环境。操作系统可以创建和销毁进程，并将资源分配给它们。

- 用户程序： 用户程序是由开发人员编写的应用程序，它们运行在操作系统之上。用户程序可以通过操作系统提供的接口（如系统调用）请求操作系统创建进程或线程。

- 父进程： 一个已经存在的进程可以通过调用操作系统提供的接口（如fork()系统调用）来创建子进程。父进程可以决定创建子进程的时机和参数，从而划分出一个新的进程。

- 线程创建者： 在一个进程中，已经存在的线程可以通过调用操作系统或编程语言提供的函数（如Thread类的构造函数）来创建新的线程。线程创建者可以指定新线程的执行函数和参数。

需要注意的是，不是所有的操作系统和编程语言都支持直接创建进程或线程的能力。具体的实现方式和接口可能会有所不同。一般来说，通过操作系统提供的API或编程语言的特定语法，可以实现进程和线程的创建和划分。

<a name="CLR为什么可以管理进程和线程"></a>
## CLR为什么可以管理进程和线程
请注意，CLR（Common Language Runtime）是负责管理和执行托管代码的运行时环境，并不直接管理操作系统级别的进程和线程。CLR是在操作系统的进程中运行的，并且依赖于操作系统提供的线程调度器来执行托管代码。

CLR能够有效地管理进程和线程的原因主要有两个方面：

- 线程管理： CLR内部有一个线程池（Thread Pool），它负责管理和调度线程的执行。线程池是一个由CLR维护的线程队列，其中包含可重用的线程。当托管代码需要执行时，CLR会从线程池中获取一个空闲线程来执行代码，而不是为每个代码块创建一个新线程。这样可以避免频繁创建和销毁线程的开销，提高程序的性能和资源利用率。

- 资源管理： CLR在运行时会负责管理托管代码使用的资源，包括内存、文件句柄、网络连接等。CLR使用垃圾回收（Garbage Collection）机制来自动管理内存，通过周期性地回收不再使用的对象释放内存资源。同时，CLR还提供了其他资源的管理机制，如使用using语句来自动释放文件句柄等资源。这样可以确保托管代码不会因为资源泄露而导致系统性能下降或者出现错误。

需要注意的是，CLR并不直接管理操作系统级别的进程。进程的创建、调度和终止等操作仍然是由操作系统负责。CLR运行在操作系统的进程中，通过操作系统提供的接口和调度器来管理和执行线程，以及与操作系统进行交互。

因此，CLR并不管理进程和线程的底层细节，它更关注于提供托管代码的执行环境和资源管理功能，以便程序员可以更方便地编写和执行托管代码。

<a name="C#异步编程"></a>
## C#异步编程

- 异步方法和关键字 `async`：  
  C# 中的异步方法使用 `async` 关键字进行标识。`async` 关键字告诉编译器该方法是一个异步方法，并且在方法内部可以使用 `await` 关键字来等待异步操作的完成。

- `Task` 和 `Task<T>`：  
  `Task` 和 `Task<T>`是表示异步操作的类型。异步方法通常会返回一个 Task 或 `Task<T>` 对象，用于表示异步操作的进行和完成。

- `await` 表达式：  
  `await` 关键字用于等待异步操作的完成。当执行到 `await` 表达式时，控制权会返回给调用者，而异步操作会在后台继续执行。一旦异步操作完成，`await` 表达式会返回其结果，然后程序继续执行下一步操作。  

  
C#异步编程模型的本质是利用异步操作来提高程序的响应性和性能，以避免阻塞主线程并充分利用系统资源。

异步编程的核心是 Task 和 Task<T> 对象，这两个对象对异步操作建模。 它们受关键字 async 和 await 的支持。 在大多数情况下模型十分简单：

对于 I/O 绑定代码，等待一个在 async 方法中返回 Task 或 Task<T> 的操作。  
对于 CPU 绑定代码，等待一个使用 Task.Run 方法在后台线程启动的操作。  

`在使用 async 关键字定义的方法中，如果没有在方法主体中使用 await 关键字，那么这个方法将不会异步执行，而是会在调用点同步地执行完成。`
`在这里，主体指的是 async 方法的方法体，也就是方法内部的代码块。当方法主体中的代码执行到遇到 await 关键字时，它会暂停当前方法的执行，并将控制权返回给调用方，允许其他代码继续执行。`
`如果在 async 方法中没有使用 await 关键字，那么该方法会像普通的同步方法一样，按顺序执行其中的代码，不会有任何的异步行为。这意味着这个方法的执行不会在遇到耗时的操作时暂停等待，而是会一直执行下去，直到方法的所有代码都执行完成。`
因此，如果在 `async` 方法中没有使用 `await` 关键字，它们将永远不会暂停执行，而是会在调用点同步地执行完成，可能会导致一些意外的行为和性能问题。因此，在编写 `async` 方法时，务必在方法主体中使用 `await` 关键字来处理异步操作，以确保正确的异步执行和控制流程。  

详情：  
  [异步编程场景MSDN链接1](https://learn.microsoft.com/zh-cn/dotnet/csharp/asynchronous-programming/async-scenarios)  
  [异步编程模型MSDN链接2](https://learn.microsoft.com/zh-cn/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model)


补充:  
移植后台线程和创建线程是不同的概念。

创建线程是指显式地使用线程创建函数或类来创建一个新的线程。在传统的多线程编程中，我们可以使用线程池、Thread类等来创建和管理线程。

而移植后台线程是指通过使用异步方法中的Task.Run或Task.Factory.StartNew等方法，将工作任务放在后台线程上执行。这些方法实际上会利用线程池中的线程来执行工作，而不需要我们显式地创建和管理线程。

在C#中，async和await关键字并不会创建额外的线程。异步方法本身并不负责线程的创建和管理，而是利用异步编程模型和任务调度机制来实现非阻塞的执行。当使用await等待一个任务时，它会将执行控制权返回给调用方，而不会阻塞当前线程。当任务完成后，它会通过回调或状态机的方式恢复执行。

使用Task.Run或Task.Factory.StartNew方法可以将工作任务移至后台线程上执行，这些后台线程是从线程池中获取的，并且可以帮助我们实现并行执行和提高程序的性能。但是需要注意的是，后台线程并不会改变等待结果的进程的可用性。在等待任务的结果时，仍然需要等待该任务完成，无论它是在后台线程还是在主线程中执行。

因此，异步方法通过利用异步编程模型和任务调度机制，实现了非阻塞的执行，并提供了更好的性能和响应性，而不需要我们显式地创建额外的线程。

  
异步返回类型 (C#)：    
在C#中，异步方法可以使用不同的返回类型，取决于其具体需求和实现方式。以下是常见的异步返回类型：

1. `Task`: 异步方法不返回任何结果，仅用于表示异步操作的完成状态。可以使用`Task`关键字作为返回类型，例如`Task DoSomethingAsync() { ... }`。

2. `Task<T>`: 异步方法返回一个结果，类型为`T`。可以使用`Task<T>`关键字作为返回类型，例如`Task<int> CalculateAsync() { ... }`。这种类型的异步方法通常用于执行耗时的计算或IO操作，并返回计算结果或IO读取的数据。

3. `ValueTask`: 异步方法返回一个值类型的结果，用于在异步操作完成时返回结果。`ValueTask`是一种优化的异步返回类型，用于避免在某些情况下不必要的堆分配。例如，`ValueTask<int> CalculateAsync() { ... }`。

4. `TaskCompletionSource`: 异步方法通过`TaskCompletionSource`对象手动创建和完成一个异步操作，并返回`Task`。可以使用`TaskCompletionSource`创建自定义的异步操作，例如在异步方法中执行一些非标准的异步操作。

这些异步返回类型提供了不同的灵活性和性能特性，可以根据具体的场景选择适合的返回类型。在使用异步方法时，根据需要选择合适的返回类型，并通过`await`关键字等待异步操作的完成。
  
<a name="C#如何做到高效的异步编程，实际生产时，编码时需要哪些规范"></a>  
## C#如何做到高效的异步编程，实际生产时，编码时需要哪些规范
  
要实现高效的异步编程，在C#中，可以采取以下几个方法和规范：

1. 使用异步关键字：使用`async`关键字标记异步方法，以便在方法内部使用`await`关键字来等待异步操作的完成。这样可以使代码更清晰、易读，并且不会阻塞主线程或其他任务。

2. 返回`Task`或`Task<T>`：在异步方法中，应该使用`Task`或`Task<T>`作为方法的返回类型，以便能够跟踪异步操作的完成状态。

3. 避免阻塞：在异步方法中，应避免使用阻塞操作，如`Thread.Sleep`或同步的I/O操作。应该使用异步的替代方案，如`Task.Delay`来模拟延迟，或者使用异步的I/O操作。

4. 合理使用并发：根据实际需求，合理使用并发编程模型，如使用并行任务`Parallel`或数据流`Dataflow`来提高性能和吞吐量。

5. 错误处理：对于异步操作，应该正确处理异常和错误情况。可以使用`try-catch`块或使用`async`方法的`try-catch`来捕获异常，并采取适当的处理措施。

6. 取消操作：为异步操作提供取消的支持，可以使用`CancellationToken`来取消异步操作，以便能够及时释放资源或停止长时间运行的操作。

7. 异步编程模式和库：熟悉并使用异步编程模式和相关的异步库，如使用`Task.Run`在后台线程上执行任务，使用`Task.WhenAny`和`Task.WhenAll`等方法来等待多个任务的完成。

8. 避免过度异步：不是所有的操作都需要异步执行，有时同步执行可能更加简单和高效。在评估时，要权衡使用异步的成本和收益。

以上是一些常见的规范和方法，用于实现高效的异步编程。在实际生产中，根据具体需求和项目要求，还可能有其他的编码规范和最佳实践。
 
<a name="本来就有线程，为撒又要异步编程"></a>  
## 本来就有线程，为撒又要异步编程
  
异步编程与线程编程是两个不同的概念，它们解决的问题和目的也不同。

线程编程是一种并发编程模型，通过创建和管理多个线程来实现并行处理和任务执行。线程在操作系统级别上被调度和执行，可以在多个核心或处理器上并行执行任务。线程编程适用于需要同时执行多个独立任务或需要实现实时响应的情况。

而异步编程是一种编程模型，用于处理非阻塞式的异步操作。异步编程不一定涉及线程的创建和管理，而是通过利用事件驱动或回调机制来处理异步操作的完成。异步编程适用于需要处理 I/O 操作、网络请求、数据库访问等可能导致阻塞的操作，以提高程序的性能和资源利用率。

异步编程的主要目的是改善程序的可响应性和吞吐量，以充分利用系统资源。通过将异步操作交给操作系统或其他异步机制处理，可以避免线程的阻塞和资源浪费，从而实现更高效的任务处理。

总结起来，异步编程不仅仅是为了利用多线程并发执行任务，而是为了在处理非阻塞式操作时提供更好的性能和响应性。在一些情况下，异步编程可以减少线程创建和上下文切换的开销，并且可以更好地利用计算资源。
  
<a name="C#如何做到高效的多线程编程，实际生产时，编码时需要哪些规范"></a>  
## C#如何做到高效的多线程编程，实际生产时，编码时需要哪些规范
  
在 C# 中进行高效的多线程编程需要考虑以下几个方面，并遵守相应的规范：

1. 使用合适的并发集合：C# 提供了一些线程安全的并发集合类，如ConcurrentQueue、ConcurrentDictionary等，它们可以在多线程环境下安全地进行操作。使用这些并发集合可以避免手动实现线程同步机制，提高编程效率和性能。

2. 使用线程池：C# 的线程池是一种用于管理和重用线程的机制。通过使用线程池，可以避免频繁地创建和销毁线程，从而减少线程开销。可以使用ThreadPool类或使用Task.Run()方法来将任务提交到线程池中执行。

3. 避免锁竞争：在多线程编程中，锁竞争是一个常见的性能瓶颈。尽量避免在频繁访问的代码段中使用过多的锁，可以使用更细粒度的锁或使用无锁数据结构来减少竞争。另外，可以使用并发集合等线程安全的数据结构来代替显式的锁操作。

4. 使用并行任务库：C# 提供了并行任务库（Parallel类和PLINQ），可以方便地进行并行化的任务处理。通过使用并行任务库，可以自动将任务分解为多个子任务，并使用多线程并发执行，提高处理速度。

5. 使用异步编程：对于 I/O 密集型的操作，使用异步编程模型可以提高应用程序的性能和可扩展性。通过使用async和await关键字，可以将异步操作与其他代码解耦，并使程序在等待异步操作完成时释放线程资源。

6. 考虑线程安全性：多线程编程涉及到共享数据的访问和修改，需要注意线程安全性。确保对共享数据的访问进行正确的同步和互斥操作，可以使用锁、互斥体、信号量等线程同步机制来保证数据的一致性和完整性。

7. 错误处理和异常处理：在多线程编程中，错误处理和异常处理非常重要。确保在多线程环境下捕获和处理异常，避免线程崩溃和资源泄漏。可以使用try-catch块来捕获异常，并确保在异常发生时正确地处理和释放相关资源。

8. 使用适当的同步机制：根据具体的需求选择适当的同步机制，如互斥锁、读写锁、信号量等。避免不必要的线程同步和阻塞，同时确保线程之间的正确通信和数据共享。

通过遵守这些规范和最佳实践，可以编写高效且健壮的多线程代码，并充分利用计算资源，提高应用程序的性能和可伸缩性。
  



