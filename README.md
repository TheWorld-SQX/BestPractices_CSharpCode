# BestPractices_CSharpCode
关于面向对象编程（OOP）一些概念知识和.NET下开发程序需要的一些相关概念知识

- [面向对象编程思想](#面向对象编程思想)
  - [类和对象](#类和对象)
  - [封装](#封装)
  - [继承](#继承)
  - [多态](#多态)
  - [抽象和接口](#抽象和接口)
- [在VS上C#编写的程序是如何运行的](#在VS上C#编写的程序是如何运行的)
- [？进程和线程](#？进程和线程)
- [操作系统怎么知道要给每个进程分配多少计算机资源的](#操作系统怎么知道要给每个进程分配多少计算机资源的)
- [谁可以创建或者说划分出一个进程或线程](#谁可以创建或者说划分出一个进程或线程)
- [CLR为什么可以管理进程和线程](#CLR为什么可以管理进程和线程)
- [C#异步编程](#C#异步编程)

## 面向对象编程思想
<a name="面向对象编程思想"></a>
面向对象编程思想（Object-Oriented Programming, OOP）是一种软件开发方法，它将程序中的数据和操作数据的方法组织成对象，通过对象之间的交互来实现程序的功能。面向对象编程将现实世界中的实体抽象为程序中的对象，通过模拟对象之间的关系和行为（也就是 类型和行为），实现对问题域的建模和解决。

<a name="类和对象"></a>
1.类和对象：

- 类是对象的模板，描述了对象的属性和行为。它定义了对象的结构和行为的集合。   
- 对象（Object）是类的实例，表示具体的实体。
- 对象是现实世界中的实体，可以具有状态（属性）和行为（方法）。

<a name="封装"></a>
2.封装（Encapsulation）：

- 封装是将数据和操作数据的方法封装在一起，形成一个对象。  
- 对象对外隐藏了内部的实现细节，只提供了公共接口（公共接口：对象对外部提供的一组可访问和操作对象数据的方法。），其他对象只能通过这些接口访问和操作对象的数据。  

<a name="继承"></a>
3.继承（Inheritance）：

- 继承是一种机制，通过定义一个新的类来继承现有类的属性和方法。  
- 继承允许新的类拥有基类的特性，可以重用已有的代码，并且可以在基础上添加新的功能或修改行为。  

<a name="多态"></a>
4.多态（Polymorphism）：

- 多态是指同一个方法名可以在不同的对象上具有不同的行为。
- 多态使得可以用一个通用的方式来处理不同类型的对象，提高了代码的灵活性和可扩展性。
- 多态是指同一个方法名可以在不同的对象上具有不同的行为。
- 多态性允许通过父类引用指向子类对象，实现运行时多态性。
- 多态通过方法的重写（覆盖）和方法的重载来实现，提高了代码的灵活性和可扩展性。  

<a name="抽象和接口"></a>
5.抽象（Abstraction）和接口：

- 抽象是一种将类的共同特征提取出来形成抽象类或接口的过程。
- 抽象类是不能被实例化的类，用于定义具有共同特征的子类的基本行为和属性。
- 接口是一组方法、属性和事件的集合，用于定义对象之间的契约。类可以实现接口，满足接口定义的行为。  

<a name="在VS上C#编写的程序是如何运行的"></a>
## 在VS上C#编写的程序是如何运行的
- 源代码编写： 在VS中，程序员使用C#语言编写源代码，实现程序的逻辑和功能。

- 编译器处理： 一旦源代码编写完成，C#编译器将源代码转换为中间语言（Intermediate Language, IL），也称为托管代码。IL是一种与特定计算机体系结构无关的中间表示形式。

- 程序集生成： 编译器将生成的IL代码打包成程序集（Assembly），其中包含了程序的IL代码、元数据（描述程序的结构和特性）、资源文件等（JIT编译：CLR将IL转换为机器码）。程序集通常以DLL或EXE的形式存在。

- 加载程序集： 当运行C#程序时，操作系统将加载程序集到内存中。这个过程通常由CLR（Common Language Runtime）负责，CLR是.NET运行时的核心组件。

- 初始化： 一旦程序集被加载到内存中，CLR负责初始化运行环境，包括分配和管理内存、设置堆栈、创建主线程等。CLR还执行一些必要的初始化操作，例如加载系统程序集、安全检查等。

- 主线程执行： CLR创建一个主线程，并从程序集中找到入口点（Entry Point），通常是Main方法。主线程负责执行程序的初始化代码和入口方法，它是程序的起点。

- 用户交互和事件处理： 如果程序包含用户界面，主线程将监听用户的输入事件，如鼠标点击、键盘输入等。主线程通过消息循环机制响应用户操作，更新UI并触发相应的事件处理逻辑。

- 多线程并发： 在C#程序中，可以创建多个线程来同时执行不同的任务。例如，可以使用Task、Thread或async/await等机制创建额外的线程来处理耗时的操作，如网络请求、文件读写等。这些线程由CLR的线程调度器进行管理和调度。

- 线程调度和并发访问： 在多线程场景下，CLR的线程调度器负责决定哪个线程在某个时间片段内执行。调度器根据优先级、时间片轮转等策略来决定线程的执行顺序。多个线程可能同时访问共享的资源，为了保证数据的一致性和避免竞态条件，需要使用同步机制（如锁、互斥量、信号量等）来协调线程之间的访问。

- 指令执行： 当线程执行时，CPU将逐条执行线程的指令。指令包括算术运算、条件判断、函数调用等操作。CLR负责将C#代码转换为对应的机器码，CPU根据机器码执行相应的指令。

- 任务完成： 程序的执行会持续进行，直到达到退出条件或主动终止。在程序结束时，CLR会执行一些清理操作，如释放资源、关闭线程等。

以上是一个概括性的描述，实际上涉及的细节非常复杂。C#程序的运行涉及到编译、加载、初始化、线程调度、指令执行等多个阶段和环节，这些概念和流程的配合协作，使得程序能够顺利运行并完成相应的任务。

<a name="？进程和线程"></a>
## ？进程和线程（是计算机科学中的概念）

进程（Process）是指正在运行的一个程序的实例。它是操作系统中进行资源分配和调度的基本单位。一个进程包含了程序的代码、数据、堆栈和相关的系统资源（如打开的文件、网络连接等）。每个进程都有独立的地址空间，它们之间相互隔离，不会直接共享内存。

线程（Thread）是进程中的一个执行单元。一个进程可以包含多个线程，线程共享进程的地址空间和资源。线程之间可以并发执行，每个线程有自己的程序计数器、栈和局部变量，但共享进程的全局变量和堆内存。

因此，进程和线程都是抽象的概念，用于描述程序的执行和资源管理方式。它们在操作系统中起到不同的作用，进程是资源分配的基本单位，而线程是执行单位，多个线程可以在同一个进程中并发执行。

<a name="操作系统怎么知道要给每个进程分配多少计算机资源的"></a>
## 操作系统怎么知道要给每个进程分配多少计算机资源的（进程是资源分配的基本单位）

操作系统根据一些策略和算法来确定要给每个进程分配多少计算机资源。这个过程称为*进程调度和资源管理*。

以下是操作系统进行资源分配的一般原则和方法：

- 优先级和调度算法： 操作系统为每个进程分配一个优先级，表示进程相对于其他进程的重要程度。优先级通常根据进程的类型、紧急性、响应时间等因素确定。操作系统使用调度算法来决定哪些进程应该被优先调度执行。

- 时间片轮转： 操作系统采用时间片轮转算法来分配CPU时间。每个进程被分配一个时间片，在时间片用完后，操作系统将CPU切换到下一个进程。这样，每个进程都有公平的机会使用CPU资源。

- 内存管理： 操作系统负责将内存分配给进程。它维护一个内存管理表，记录每个进程的内存需求和已分配的内存块。根据进程的大小和内存的可用性，操作系统决定如何分配内存资源给每个进程。

- 文件和I/O资源管理： 操作系统管理文件和I/O设备资源的分配。它维护文件表和设备表，记录文件和设备的使用情况。当进程请求使用文件或进行I/O操作时，操作系统根据资源的可用性和访问权限来分配给进程相应的资源。

- 并发控制和同步： 多个进程可能同时访问共享资源，如共享内存、文件等。为了保证数据的一致性和避免竞态条件，操作系统提供了并发控制和同步机制，如锁、信号量、互斥量等。这些机制确保每个进程能够按照规定的顺序和方式访问共享资源，避免冲突和数据损坏。

通过以上的策略和算法，操作系统能够根据进程的优先级、时间片、内存需求、文件和I/O资源等因素来分配适当的计算机资源给每个进程，以满足各个进程的运行需求。这样可以实现资源的合理利用和进程的高效执行。

<a name="谁可以创建或者说划分出一个进程或线程"></a>
## 谁可以创建或者说划分一个进程或线程

在操作系统中，通常有以下实体可以创建或者划分出一个进程或线程：

- 操作系统自身： 操作系统内核是最高权限的程序，它负责管理计算机的硬件资源和执行环境。操作系统可以创建和销毁进程，并将资源分配给它们。

- 用户程序： 用户程序是由开发人员编写的应用程序，它们运行在操作系统之上。用户程序可以通过操作系统提供的接口（如系统调用）请求操作系统创建进程或线程。

- 父进程： 一个已经存在的进程可以通过调用操作系统提供的接口（如fork()系统调用）来创建子进程。父进程可以决定创建子进程的时机和参数，从而划分出一个新的进程。

- 线程创建者： 在一个进程中，已经存在的线程可以通过调用操作系统或编程语言提供的函数（如Thread类的构造函数）来创建新的线程。线程创建者可以指定新线程的执行函数和参数。

需要注意的是，不是所有的操作系统和编程语言都支持直接创建进程或线程的能力。具体的实现方式和接口可能会有所不同。一般来说，通过操作系统提供的API或编程语言的特定语法，可以实现进程和线程的创建和划分。

<a name="CLR为什么可以管理进程和线程"></a>
## CLR为什么可以管理进程和线程
请注意，CLR（Common Language Runtime）是负责管理和执行托管代码的运行时环境，并不直接管理操作系统级别的进程和线程。CLR是在操作系统的进程中运行的，并且依赖于操作系统提供的线程调度器来执行托管代码。

CLR能够有效地管理进程和线程的原因主要有两个方面：

- 线程管理： CLR内部有一个线程池（Thread Pool），它负责管理和调度线程的执行。线程池是一个由CLR维护的线程队列，其中包含可重用的线程。当托管代码需要执行时，CLR会从线程池中获取一个空闲线程来执行代码，而不是为每个代码块创建一个新线程。这样可以避免频繁创建和销毁线程的开销，提高程序的性能和资源利用率。

- 资源管理： CLR在运行时会负责管理托管代码使用的资源，包括内存、文件句柄、网络连接等。CLR使用垃圾回收（Garbage Collection）机制来自动管理内存，通过周期性地回收不再使用的对象释放内存资源。同时，CLR还提供了其他资源的管理机制，如使用using语句来自动释放文件句柄等资源。这样可以确保托管代码不会因为资源泄露而导致系统性能下降或者出现错误。

需要注意的是，CLR并不直接管理操作系统级别的进程。进程的创建、调度和终止等操作仍然是由操作系统负责。CLR运行在操作系统的进程中，通过操作系统提供的接口和调度器来管理和执行线程，以及与操作系统进行交互。

因此，CLR并不管理进程和线程的底层细节，它更关注于提供托管代码的执行环境和资源管理功能，以便程序员可以更方便地编写和执行托管代码。

<a name="C#异步编程"></a>
## C#异步编程
C#异步编程模型的本质是利用异步操作来提高程序的响应性和性能，以避免阻塞主线程并充分利用系统资源。

异步编程的核心是 Task 和 Task<T> 对象，这两个对象对异步操作建模。 它们受关键字 async 和 await 的支持。 在大多数情况下模型十分简单：

对于 I/O 绑定代码，等待一个在 async 方法中返回 Task 或 Task<T> 的操作。  
对于 CPU 绑定代码，等待一个使用 Task.Run 方法在后台线程启动的操作。  

- 异步方法和关键字 async：  
  C# 中的异步方法使用 async 关键字进行标识。async 关键字告诉编译器该方法是一个异步方法，并且在方法内部可以使用 await 关键字来等待异步操作的完成。

- Task 和 'Task<T>'：  
  Task 和 'Task<T>' 是表示异步操作的类型。异步方法通常会返回一个 Task 或 'Task<T>' 对象，用于表示异步操作的进行和完成。

- await 表达式：  
  await 关键字用于等待异步操作的完成。当执行到 await 表达式时，控制权会返回给调用者，而异步操作会在后台继续执行。一旦异步操作完成，await 表达式会返回其结果，然后程序继续执行下一步操作。
  
详情：[异步编程MSDN链接](https://learn.microsoft.com/zh-cn/dotnet/csharp/asynchronous-programming/async-scenarios).

  



